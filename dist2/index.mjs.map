{"version":3,"file":"index.mjs","sources":["../src/utils/typeOf.ts","../src/utils/isEmpty.ts","../src/utils/isCharInRange.ts","../src/constants.ts","../src/utils/isCharJapanese.ts","../src/isJapanese.ts","../node_modules/memoize-one/dist/memoize-one.esm.js","../node_modules/dequal/dist/index.mjs","../src/utils/mergeWithDefaultOptions.ts","../src/utils/kanaMapping.ts","../src/utils/romajiToKanaMap.ts","../src/utils/isCharUpperCase.ts","../src/utils/isCharLongDash.ts","../src/utils/isCharSlashDot.ts","../src/utils/isCharHiragana.ts","../src/utils/hiraganaToKatakana.ts","../src/toKana.ts","../src/utils/dom.ts","../src/utils/logInputEvents.ts","../src/bind.ts","../src/unbind.ts","../src/utils/isCharRomaji.ts","../src/isRomaji.ts","../src/utils/isCharKatakana.ts","../src/utils/isCharKana.ts","../src/isKana.ts","../src/isHiragana.ts","../src/isKatakana.ts","../src/utils/isCharKanji.ts","../src/isKanji.ts","../src/isMixed.ts","../src/utils/katakanaToHiragana.ts","../src/utils/kanaToRomajiMap.ts","../src/toRomaji.ts","../src/utils/isCharEnglishPunctuation.ts","../src/toHiragana.ts","../src/toKatakana.ts","../src/utils/isCharJapanesePunctuation.ts","../src/tokenize.ts","../src/stripOkurigana.ts"],"sourcesContent":["/**\n * Returns detailed type as string (instead of just 'object' for arrays etc)\n * @private\n * @param {any} value js value\n * @returns {String} type of value\n * @example\n * typeOf({}); // 'object'\n * typeOf([]); // 'array'\n * typeOf(function() {}); // 'function'\n * typeOf(/a/); // 'regexp'\n * typeOf(new Date()); // 'date'\n * typeOf(null); // 'null'\n * typeOf(undefined); // 'undefined'\n * typeOf('a'); // 'string'\n * typeOf(1); // 'number'\n * typeOf(true); // 'boolean'\n * typeOf(new Map()); // 'map'\n * typeOf(new Set()); // 'map'\n */\nfunction typeOf(value: unknown): string {\n  if (value === null) {\n    return 'null';\n  }\n  if (value !== Object(value)) {\n    return typeof value;\n  }\n  return {}.toString\n    .call(value)\n    .slice(8, -1)\n    .toLowerCase();\n}\n\nexport default typeOf;\n","import typeOf from './typeOf';\n/**\n * Checks if input string is empty\n * @param  {String} input text input\n * @return {Boolean} true if no input\n */\nfunction isEmpty(input: unknown) {\n  if (typeOf(input) !== 'string') {\n    return true;\n  }\n  return !(input as string).length;\n}\n\nexport default isEmpty;\n","import isEmpty from './isEmpty';\n\n/**\n * Takes a character and a unicode range. Returns true if the char is in the range.\n * @param  {String}  char  unicode character\n * @param  {Number}  start unicode start range\n * @param  {Number}  end   unicode end range\n * @return {Boolean}\n */\nfunction isCharInRange(char = '', start, end) {\n  if (isEmpty(char)) return false;\n  const code = char.charCodeAt(0);\n  return start <= code && code <= end;\n}\n\nexport default isCharInRange;\n","export const VERSION = '5.0.2';\n\nexport const TO_KANA_METHODS = {\n  HIRAGANA: 'toHiragana',\n  KATAKANA: 'toKatakana',\n};\n\nexport const ROMANIZATIONS = {\n  HEPBURN: 'hepburn',\n};\n\n/**\n * Default config for WanaKana, user passed options will be merged with these\n * @type {DefaultOptions}\n * @name defaultOptions\n * @property {Boolean} [useObsoleteKana=false] - Set to true to use obsolete characters, such as ゐ and ゑ.\n * @example\n * toHiragana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * @property {Boolean} [passRomaji=false] - Set to true to pass romaji when using mixed syllabaries with toKatakana() or toHiragana()\n * @example\n * toHiragana('only convert the katakana: ヒラガナ', { passRomaji: true })\n * // => \"only convert the katakana: ひらがな\"\n * @property {Object} [convertLongVowelMark=true] - Set to false to prevent conversions of 'ー' to extended vowels with toHiragana()\n * @example\n * toHiragana('ラーメン', { convertLongVowelMark: false });\n * // => 'らーめん\n * @property {Boolean} [upcaseKatakana=false] - Set to true to convert katakana to uppercase using toRomaji()\n * @example\n * toRomaji('ひらがな カタカナ', { upcaseKatakana: true })\n * // => \"hiragana KATAKANA\"\n * @property {Boolean|String} [IMEMode=false] - Set to true, 'toHiragana', or 'toKatakana' to handle conversion while it is being typed.\n * @property {String} [romanization='hepburn'] - choose toRomaji() romanization map (currently only 'hepburn')\n * @property {Object} [customKanaMapping] - custom map will be merged with default conversion\n * @example\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'Bana' }) };\n * // => 'わにBanaに'\n * @property {Object} [customRomajiMapping] - custom map will be merged with default conversion\n * @example\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' }) };\n * // => 'tuzigili'\n */\nexport const DEFAULT_OPTIONS = {\n  useObsoleteKana: false,\n  passRomaji: false,\n  upcaseKatakana: false,\n  IMEMode: false,\n  convertLongVowelMark: true,\n  romanization: ROMANIZATIONS.HEPBURN,\n};\n\n// CharCode References\n// http://www.rikai.com/library/kanjitables/kanji_codes.unicode.shtml\n// http://unicode-table.com\n\nexport const LATIN_LOWERCASE_START = 0x61;\nexport const LATIN_LOWERCASE_END = 0x7a;\nexport const LATIN_UPPERCASE_START = 0x41;\nexport const LATIN_UPPERCASE_END = 0x5a;\nexport const LOWERCASE_ZENKAKU_START = 0xff41;\nexport const LOWERCASE_ZENKAKU_END = 0xff5a;\nexport const UPPERCASE_ZENKAKU_START = 0xff21;\nexport const UPPERCASE_ZENKAKU_END = 0xff3a;\nexport const HIRAGANA_START = 0x3041;\nexport const HIRAGANA_END = 0x3096;\nexport const KATAKANA_START = 0x30a1;\nexport const KATAKANA_END = 0x30fc;\nexport const KANJI_START = 0x4e00;\nexport const KANJI_END = 0x9faf;\nexport const PROLONGED_SOUND_MARK = 0x30fc;\nexport const KANA_SLASH_DOT = 0x30fb;\n\nconst ZENKAKU_NUMBERS = [0xff10, 0xff19];\nconst ZENKAKU_UPPERCASE = [UPPERCASE_ZENKAKU_START, UPPERCASE_ZENKAKU_END];\nconst ZENKAKU_LOWERCASE = [LOWERCASE_ZENKAKU_START, LOWERCASE_ZENKAKU_END];\nconst ZENKAKU_PUNCTUATION_1 = [0xff01, 0xff0f];\nconst ZENKAKU_PUNCTUATION_2 = [0xff1a, 0xff1f];\nconst ZENKAKU_PUNCTUATION_3 = [0xff3b, 0xff3f];\nconst ZENKAKU_PUNCTUATION_4 = [0xff5b, 0xff60];\nconst ZENKAKU_SYMBOLS_CURRENCY = [0xffe0, 0xffee];\n\nconst HIRAGANA_CHARS = [0x3040, 0x309f];\nconst KATAKANA_CHARS = [0x30a0, 0x30ff];\nconst HANKAKU_KATAKANA = [0xff66, 0xff9f];\nconst KATAKANA_PUNCTUATION = [0x30fb, 0x30fc];\nconst KANA_PUNCTUATION = [0xff61, 0xff65];\nconst CJK_SYMBOLS_PUNCTUATION = [0x3000, 0x303f];\nconst COMMON_CJK = [0x4e00, 0x9fff];\nconst RARE_CJK = [0x3400, 0x4dbf];\n\nexport const KANA_RANGES = [\n  HIRAGANA_CHARS,\n  KATAKANA_CHARS,\n  KANA_PUNCTUATION,\n  HANKAKU_KATAKANA,\n];\n\nexport const JA_PUNCTUATION_RANGES = [\n  CJK_SYMBOLS_PUNCTUATION,\n  KANA_PUNCTUATION,\n  KATAKANA_PUNCTUATION,\n  ZENKAKU_PUNCTUATION_1,\n  ZENKAKU_PUNCTUATION_2,\n  ZENKAKU_PUNCTUATION_3,\n  ZENKAKU_PUNCTUATION_4,\n  ZENKAKU_SYMBOLS_CURRENCY,\n];\n\n// All Japanese unicode start and end ranges\n// Includes kanji, kana, zenkaku latin chars, punctuation, and number ranges.\nexport const JAPANESE_RANGES = [\n  ...KANA_RANGES,\n  ...JA_PUNCTUATION_RANGES,\n  ZENKAKU_UPPERCASE,\n  ZENKAKU_LOWERCASE,\n  ZENKAKU_NUMBERS,\n  COMMON_CJK,\n  RARE_CJK,\n];\n\nconst MODERN_ENGLISH = [0x0000, 0x007f];\nconst HEPBURN_MACRON_RANGES = [\n  [0x0100, 0x0101], // Ā ā\n  [0x0112, 0x0113], // Ē ē\n  [0x012a, 0x012b], // Ī ī\n  [0x014c, 0x014d], // Ō ō\n  [0x016a, 0x016b], // Ū ū\n];\nconst SMART_QUOTE_RANGES = [\n  [0x2018, 0x2019], // ‘ ’\n  [0x201c, 0x201d], // “ ”\n];\n\nexport const ROMAJI_RANGES = [MODERN_ENGLISH, ...HEPBURN_MACRON_RANGES];\n\nexport const EN_PUNCTUATION_RANGES = [\n  [0x20, 0x2f],\n  [0x3a, 0x3f],\n  [0x5b, 0x60],\n  [0x7b, 0x7e],\n  ...SMART_QUOTE_RANGES,\n];\n","import isCharInRange from './isCharInRange';\nimport { JAPANESE_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanese(char = '') {\n  return JAPANESE_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanese;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharJapanese from './utils/isCharJapanese';\n\n/**\n * Test if `input` only includes [Kanji](https://en.wikipedia.org/wiki/Kanji), [Kana](https://en.wikipedia.org/wiki/Kana), zenkaku numbers, and JA punctuation/symbols.”\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if passes checks\n * @example\n * isJapanese('泣き虫')\n * // => true\n * isJapanese('あア')\n * // => true\n * isJapanese('２月') // Zenkaku numbers allowed\n * // => true\n * isJapanese('泣き虫。！〜＄') // Zenkaku/JA punctuation\n * // => true\n * isJapanese('泣き虫.!~$') // Latin punctuation fails\n * // => false\n * isJapanese('A泣き虫')\n * // => false\n * isJapanese('≪偽括弧≫', /[≪≫]/);\n * // => true\n */\nfunction isJapanese(input = '', allowed?: RegExp) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isJa = isCharJapanese(char);\n      return !augmented ? isJa : isJa || allowed!.test(char);\n    });\n}\n\nexport default isJapanese;\n","var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var cache = null;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (cache && cache.lastThis === this && isEqual(newArgs, cache.lastArgs)) {\n            return cache.lastResult;\n        }\n        var lastResult = resultFn.apply(this, newArgs);\n        cache = {\n            lastResult: lastResult,\n            lastArgs: newArgs,\n            lastThis: this,\n        };\n        return lastResult;\n    }\n    memoized.clear = function clear() {\n        cache = null;\n    };\n    return memoized;\n}\n\nexport { memoizeOne as default };\n","var has = Object.prototype.hasOwnProperty;\n\nfunction find(iter, tar, key) {\n\tfor (key of iter.keys()) {\n\t\tif (dequal(key, tar)) return key;\n\t}\n}\n\nexport function dequal(foo, bar) {\n\tvar ctor, len, tmp;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ctor === Set) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len;\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!bar.has(tmp)) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === Map) {\n\t\t\tif (foo.size !== bar.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (len of foo) {\n\t\t\t\ttmp = len[0];\n\t\t\t\tif (tmp && typeof tmp === 'object') {\n\t\t\t\t\ttmp = find(bar, tmp);\n\t\t\t\t\tif (!tmp) return false;\n\t\t\t\t}\n\t\t\t\tif (!dequal(len[1], bar.get(tmp))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tif (ctor === ArrayBuffer) {\n\t\t\tfoo = new Uint8Array(foo);\n\t\t\tbar = new Uint8Array(bar);\n\t\t} else if (ctor === DataView) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo.getInt8(len) === bar.getInt8(len));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (ArrayBuffer.isView(foo)) {\n\t\t\tif ((len=foo.byteLength) === bar.byteLength) {\n\t\t\t\twhile (len-- && foo[len] === bar[len]);\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { DEFAULT_OPTIONS } from '../constants';\n\nexport interface Options {\n  useObsoleteKana: boolean,\n  passRomaji: boolean,\n  upcaseKatakana: boolean,\n  IMEMode: boolean,\n  convertLongVowelMark: boolean,\n  romanization: string,\n}\n\n/**\n * Easy re-use of merging with default options\n * @param {Object} opts user options\n * @returns user options merged over default options\n */\nconst mergeWithDefaultOptions = (opts: Partial<Options> = {}): Options => Object.assign({}, DEFAULT_OPTIONS, opts);\n\nexport default mergeWithDefaultOptions;\n","import typeOf from './typeOf';\n\nexport function applyMapping(str: string, mapping, convertEnding) {\n  const root = mapping;\n\n  function nextSubtree(tree, nextChar) {\n    const subtree = tree[nextChar];\n    if (subtree === undefined) {\n      return undefined;\n    }\n    // if the next child node does not have a node value, set its node value to the input\n    return Object.assign({ '': tree[''] + nextChar }, tree[nextChar]);\n  }\n\n  function newChunk(remaining: string, currentCursor: number) {\n    // start parsing a new chunk\n    const firstChar = remaining.charAt(0);\n\n    return parse(\n      Object.assign({ '': firstChar }, root[firstChar]),\n      remaining.slice(1),\n      currentCursor,\n      currentCursor + 1\n    );\n  }\n\n  function parse(tree, remaining: string, lastCursor: number, currentCursor: number) {\n    if (!remaining) {\n      if (convertEnding || Object.keys(tree).length === 1) {\n        // nothing more to consume, just commit the last chunk and return it\n        // so as to not have an empty element at the end of the result\n        return tree[''] ? [[lastCursor, currentCursor, tree['']]] : [];\n      }\n      // if we don't want to convert the ending, because there are still possible continuations\n      // return null as the final node value\n      return [[lastCursor, currentCursor, null]];\n    }\n\n    if (Object.keys(tree).length === 1) {\n      return [[lastCursor, currentCursor, tree['']]].concat(\n        newChunk(remaining, currentCursor)\n      );\n    }\n\n    const subtree = nextSubtree(tree, remaining.charAt(0));\n\n    if (subtree === undefined) {\n      return [[lastCursor, currentCursor, tree['']]].concat(\n        newChunk(remaining, currentCursor)\n      );\n    }\n    // continue current branch\n    return parse(subtree, remaining.slice(1), lastCursor, currentCursor + 1);\n  }\n\n  return newChunk(str, 0);\n}\n\n// transform the tree, so that for example hepburnTree['ゔ']['ぁ'][''] === 'va'\n// or kanaTree['k']['y']['a'][''] === 'きゃ'\nexport function transform(tree) {\n  return Object.entries(tree).reduce((map, [char, subtree]) => {\n    const endOfBranch = typeOf(subtree) === 'string';\n    // eslint-disable-next-line no-param-reassign\n    map[char] = endOfBranch ? { '': subtree } : transform(subtree);\n    return map;\n  }, {});\n}\n\nexport function getSubTreeOf(tree, string) {\n  return string.split('').reduce((correctSubTree, char) => {\n    if (correctSubTree[char] === undefined) {\n      // eslint-disable-next-line no-param-reassign\n      correctSubTree[char] = {};\n    }\n    return correctSubTree[char];\n  }, tree);\n}\n\n/**\n * Creates a custom mapping tree, returns a function that accepts a defaultMap which the newly created customMapping will be merged with and returned\n * (customMap) => (defaultMap) => mergedMap\n * @param  {Object} customMap { 'ka' : 'な' }\n * @return {Function} (defaultMap) => defaultMergedWithCustomMap\n * @example\n * const sillyMap = createCustomMapping({ 'ちゃ': 'time', '茎': 'cookie'　});\n * // sillyMap is passed defaultMapping to merge with when called in toRomaji()\n * toRomaji(\"It's 茎 ちゃ よ\", { customRomajiMapping: sillyMap });\n * // => 'It's cookie time yo';\n */\nexport function createCustomMapping(customMap = {}) {\n  const customTree = {};\n\n  if (typeOf(customMap) === 'object') {\n    Object.entries(customMap).forEach(([roma, kana]) => {\n      let subTree = customTree;\n      roma.split('').forEach((char) => {\n        if (subTree[char] === undefined) {\n          subTree[char] = {};\n        }\n        subTree = subTree[char];\n      });\n      subTree[''] = kana;\n    });\n  }\n\n  return function makeMap(map) {\n    const mapCopy = JSON.parse(JSON.stringify(map));\n\n    function transformMap(mapSubtree, customSubtree) {\n      if (mapSubtree === undefined || typeOf(mapSubtree) === 'string') {\n        return customSubtree;\n      }\n      return Object.entries(customSubtree).reduce(\n        (newSubtree, [char, subtree]) => {\n          // eslint-disable-next-line no-param-reassign\n          newSubtree[char] = transformMap(mapSubtree[char], subtree);\n          return newSubtree;\n        },\n        mapSubtree\n      );\n    }\n\n    return transformMap(mapCopy, customTree);\n  };\n}\n\n// allow consumer to pass either function or object as customMapping\nexport function mergeCustomMapping(map, customMapping) {\n  if (!customMapping) {\n    return map;\n  }\n  return typeOf(customMapping) === 'function'\n    ? customMapping(map)\n    : createCustomMapping(customMapping)(map);\n}\n","import { transform, getSubTreeOf, createCustomMapping } from './kanaMapping';\n\n// NOTE: not exactly kunrei shiki, for example ぢゃ -> dya instead of zya, to avoid name clashing\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_KUNREI = {\n  a: 'あ', i: 'い', u: 'う', e: 'え', o: 'お',\n  k: { a: 'か', i: 'き', u: 'く', e: 'け', o: 'こ', },\n  s: { a: 'さ', i: 'し', u: 'す', e: 'せ', o: 'そ', },\n  t: { a: 'た', i: 'ち', u: 'つ', e: 'て', o: 'と', },\n  n: { a: 'な', i: 'に', u: 'ぬ', e: 'ね', o: 'の', },\n  h: { a: 'は', i: 'ひ', u: 'ふ', e: 'へ', o: 'ほ', },\n  m: { a: 'ま', i: 'み', u: 'む', e: 'め', o: 'も', },\n  y: { a: 'や', u: 'ゆ', o: 'よ' },\n  r: { a: 'ら', i: 'り', u: 'る', e: 'れ', o: 'ろ', },\n  w: { a: 'わ', i: 'ゐ', e: 'ゑ', o: 'を', },\n  g: { a: 'が', i: 'ぎ', u: 'ぐ', e: 'げ', o: 'ご', },\n  z: { a: 'ざ', i: 'じ', u: 'ず', e: 'ぜ', o: 'ぞ', },\n  d: { a: 'だ', i: 'ぢ', u: 'づ', e: 'で', o: 'ど', },\n  b: { a: 'ば', i: 'び', u: 'ぶ', e: 'べ', o: 'ぼ', },\n  p: { a: 'ぱ', i: 'ぴ', u: 'ぷ', e: 'ぺ', o: 'ぽ', },\n  v: { a: 'ゔぁ', i: 'ゔぃ', u: 'ゔ', e: 'ゔぇ', o: 'ゔぉ', },\n};\n\nconst SPECIAL_SYMBOLS = {\n  '.': '。',\n  ',': '、',\n  ':': '：',\n  '/': '・',\n  '!': '！',\n  '?': '？',\n  '~': '〜',\n  '-': 'ー',\n  '‘': '「',\n  '’': '」',\n  '“': '『',\n  '”': '』',\n  '[': '［',\n  ']': '］',\n  '(': '（',\n  ')': '）',\n  '{': '｛',\n  '}': '｝',\n};\n\nconst CONSONANTS = {\n  k: 'き',\n  s: 'し',\n  t: 'ち',\n  n: 'に',\n  h: 'ひ',\n  m: 'み',\n  r: 'り',\n  g: 'ぎ',\n  z: 'じ',\n  d: 'ぢ',\n  b: 'び',\n  p: 'ぴ',\n  v: 'ゔ',\n  q: 'く',\n  f: 'ふ',\n};\nconst SMALL_Y = { ya: 'ゃ', yi: 'ぃ', yu: 'ゅ', ye: 'ぇ', yo: 'ょ' };\nconst SMALL_VOWELS = { a: 'ぁ', i: 'ぃ', u: 'ぅ', e: 'ぇ', o: 'ぉ' };\n\n// typing one should be the same as having typed the other instead\nconst ALIASES = {\n  sh: 'sy', // sha -> sya\n  ch: 'ty', // cho -> tyo\n  cy: 'ty', // cyo -> tyo\n  chy: 'ty', // chyu -> tyu\n  shy: 'sy', // shya -> sya\n  j: 'zy', // ja -> zya\n  jy: 'zy', // jye -> zye\n\n  // exceptions to above rules\n  shi: 'si',\n  chi: 'ti',\n  tsu: 'tu',\n  ji: 'zi',\n  fu: 'hu',\n};\n\n// xtu -> っ\nconst SMALL_LETTERS = Object.assign(\n  {\n    tu: 'っ',\n    wa: 'ゎ',\n    ka: 'ヵ',\n    ke: 'ヶ',\n  },\n  SMALL_VOWELS,\n  SMALL_Y\n);\n\n// don't follow any notable patterns\nconst SPECIAL_CASES = {\n  yi: 'い',\n  wu: 'う',\n  ye: 'いぇ',\n  wi: 'うぃ',\n  we: 'うぇ',\n  kwa: 'くぁ',\n  whu: 'う',\n  // because it's not thya for てゃ but tha\n  // and tha is not てぁ, but てゃ\n  tha: 'てゃ',\n  thu: 'てゅ',\n  tho: 'てょ',\n  dha: 'でゃ',\n  dhu: 'でゅ',\n  dho: 'でょ',\n};\n\nconst AIUEO_CONSTRUCTIONS = {\n  wh: 'う',\n  kw: 'く',\n  qw: 'く',\n  q: 'く',\n  gw: 'ぐ',\n  sw: 'す',\n  ts: 'つ',\n  th: 'て',\n  tw: 'と',\n  dh: 'で',\n  dw: 'ど',\n  fw: 'ふ',\n  f: 'ふ',\n};\n\n/* eslint-enable */\nfunction createRomajiToKanaMap() {\n  const kanaTree = transform(BASIC_KUNREI);\n  // pseudo partial application\n  const subtreeOf = (string) => getSubTreeOf(kanaTree, string);\n\n  // add tya, sya, etc.\n  Object.entries(CONSONANTS).forEach(([consonant, yKana]) => {\n    Object.entries(SMALL_Y).forEach(([roma, kana]) => {\n      // for example kyo -> き + ょ\n      subtreeOf(consonant + roma)[''] = yKana + kana;\n    });\n  });\n\n  Object.entries(SPECIAL_SYMBOLS).forEach(([symbol, jsymbol]) => {\n    subtreeOf(symbol)[''] = jsymbol;\n  });\n\n  // things like うぃ, くぃ, etc.\n  Object.entries(AIUEO_CONSTRUCTIONS).forEach(([consonant, aiueoKana]) => {\n    Object.entries(SMALL_VOWELS).forEach(([vowel, kana]) => {\n      const subtree = subtreeOf(consonant + vowel);\n      subtree[''] = aiueoKana + kana;\n    });\n  });\n\n  // different ways to write ん\n  ['n', \"n'\", 'xn'].forEach((nChar) => {\n    subtreeOf(nChar)[''] = 'ん';\n  });\n\n  // c is equivalent to k, but not for chi, cha, etc. that's why we have to make a copy of k\n  kanaTree.c = JSON.parse(JSON.stringify(kanaTree.k));\n\n  Object.entries(ALIASES).forEach(([string, alternative]) => {\n    const allExceptLast = string.slice(0, string.length - 1);\n    const last = string.charAt(string.length - 1);\n    const parentTree = subtreeOf(allExceptLast);\n    // copy to avoid recursive containment\n    parentTree[last] = JSON.parse(JSON.stringify(subtreeOf(alternative)));\n  });\n\n  function getAlternatives(string) {\n    return [...Object.entries(ALIASES), ...[['c', 'k']]].reduce(\n      (list, [alt, roma]) => (string.startsWith(roma) ? list.concat(string.replace(roma, alt)) : list),\n      []\n    );\n  }\n\n  Object.entries(SMALL_LETTERS).forEach(([kunreiRoma, kana]) => {\n    const last = (char) => char.charAt(char.length - 1);\n    const allExceptLast = (chars) => chars.slice(0, chars.length - 1);\n    const xRoma = `x${kunreiRoma}`;\n    const xSubtree = subtreeOf(xRoma);\n    xSubtree[''] = kana;\n\n    // ltu -> xtu -> っ\n    const parentTree = subtreeOf(`l${allExceptLast(kunreiRoma)}`);\n    parentTree[last(kunreiRoma)] = xSubtree;\n\n    // ltsu -> ltu -> っ\n    getAlternatives(kunreiRoma).forEach((altRoma) => {\n      ['l', 'x'].forEach((prefix) => {\n        const altParentTree = subtreeOf(prefix + allExceptLast(altRoma));\n        altParentTree[last(altRoma)] = subtreeOf(prefix + kunreiRoma);\n      });\n    });\n  });\n\n  Object.entries(SPECIAL_CASES).forEach(([string, kana]) => {\n    subtreeOf(string)[''] = kana;\n  });\n\n  // add kka, tta, etc.\n  function addTsu(tree) {\n    return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n      if (!key) {\n        // we have reached the bottom of this branch\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = `っ${value}`;\n      } else {\n        // more subtrees\n        // eslint-disable-next-line no-param-reassign\n        tsuTree[key] = addTsu(value);\n      }\n      return tsuTree;\n    }, {});\n  }\n  // have to explicitly name c here, because we made it a copy of k, not a reference\n  [...Object.keys(CONSONANTS), 'c', 'y', 'w', 'j'].forEach((consonant) => {\n    const subtree = kanaTree[consonant];\n    subtree[consonant] = addTsu(subtree);\n  });\n  // nn should not be っん\n  delete kanaTree.n.n;\n  // solidify the results, so that there there is referential transparency within the tree\n  return Object.freeze(JSON.parse(JSON.stringify(kanaTree)));\n}\n\nlet romajiToKanaMap = null;\n\nexport function getRomajiToKanaTree() {\n  if (romajiToKanaMap == null) {\n    romajiToKanaMap = createRomajiToKanaMap();\n  }\n  return romajiToKanaMap;\n}\n\nexport const USE_OBSOLETE_KANA_MAP = createCustomMapping({\n  wi: 'ゐ',\n  we: 'ゑ',\n});\n\nexport function IME_MODE_MAP(map) {\n  // in IME mode, we do not want to convert single ns\n  const mapCopy = JSON.parse(JSON.stringify(map));\n  mapCopy.n.n = { '': 'ん' };\n  mapCopy.n[' '] = { '': 'ん' };\n  return mapCopy;\n}\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { LATIN_UPPERCASE_START, LATIN_UPPERCASE_END } from '../constants';\n\n/**\n * Tests if char is in English unicode uppercase range\n * @param  {String} char\n * @return {Boolean}\n */\nfunction isCharUpperCase(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharInRange(char, LATIN_UPPERCASE_START, LATIN_UPPERCASE_END);\n}\n\nexport default isCharUpperCase;\n","import isEmpty from './isEmpty';\nimport { PROLONGED_SOUND_MARK } from '../constants';\n\n/**\n * Returns true if char is 'ー'\n * @param  {String} char to test\n * @return {Boolean}\n */\nfunction isCharLongDash(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === PROLONGED_SOUND_MARK;\n}\n\nexport default isCharLongDash;\n","import isEmpty from './isEmpty';\nimport { KANA_SLASH_DOT } from '../constants';\n\n/**\n * Tests if char is '・'\n * @param  {String} char\n * @return {Boolean} true if '・'\n */\nfunction isCharSlashDot(char = '') {\n  if (isEmpty(char)) return false;\n  return char.charCodeAt(0) === KANA_SLASH_DOT;\n}\n\nexport default isCharSlashDot;\n","import isEmpty from './isEmpty';\nimport isCharLongDash from './isCharLongDash';\nimport isCharInRange from './isCharInRange';\nimport {\n  HIRAGANA_START,\n  HIRAGANA_END,\n} from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharHiragana(char = '') {\n  if (isEmpty(char)) return false;\n  if (isCharLongDash(char)) return true;\n  return isCharInRange(char, HIRAGANA_START, HIRAGANA_END);\n}\n\nexport default isCharHiragana;\n","import { KATAKANA_START, HIRAGANA_START } from '../constants';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharHiragana from './isCharHiragana';\n\n/**\n * Convert [Hiragana](https://en.wikipedia.org/wiki/Hiragana) to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * Passes through any non-hiragana chars\n * @private\n * @param  {String} [input=''] text input\n * @return {String} converted text\n * @example\n * hiraganaToKatakana('ひらがな')\n * // => \"ヒラガナ\"\n * hiraganaToKatakana('ひらがな is a type of kana')\n * // => \"ヒラガナ is a type of kana\"\n */\nfunction hiraganaToKatakana(input = '') {\n  const kata: string[] = [];\n  input.split('').forEach((char) => {\n    // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n    if (isCharLongDash(char) || isCharSlashDot(char)) {\n      kata.push(char);\n    } else if (isCharHiragana(char)) {\n      // Shift charcode.\n      const code = char.charCodeAt(0) + (KATAKANA_START - HIRAGANA_START);\n      const kataChar = String.fromCharCode(code);\n      kata.push(kataChar);\n    } else {\n      // Pass non-hiragana chars through\n      kata.push(char);\n    }\n  });\n  return kata.join('');\n}\n\nexport default hiraganaToKatakana;\n","import memoizeOne from 'memoize-one';\nimport { dequal } from 'dequal';\n\nimport { TO_KANA_METHODS } from './constants';\nimport mergeWithDefaultOptions, { type Options } from './utils/mergeWithDefaultOptions';\nimport {\n  getRomajiToKanaTree,\n  IME_MODE_MAP,\n  USE_OBSOLETE_KANA_MAP,\n} from './utils/romajiToKanaMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\nimport isCharUpperCase from './utils/isCharUpperCase';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\n\n// memoize and deeply compare args so we only recreate when necessary\nexport const createRomajiToKanaMap = memoizeOne(\n  (IMEMode, useObsoleteKana, customKanaMapping) => {\n    let map = getRomajiToKanaTree();\n\n    map = IMEMode ? IME_MODE_MAP(map) : map;\n    map = useObsoleteKana ? USE_OBSOLETE_KANA_MAP(map) : map;\n\n    if (customKanaMapping) {\n      map = mergeCustomMapping(map, customKanaMapping);\n    }\n\n    return map;\n  },\n  dequal\n);\n\n/**\n * Convert [Romaji](https://en.wikipedia.org/wiki/Romaji) to [Kana](https://en.wikipedia.org/wiki/Kana), lowercase text will result in [Hiragana](https://en.wikipedia.org/wiki/Hiragana) and uppercase text will result in [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKana('onaji BUTTSUUJI')\n * // => 'おなじ ブッツウジ'\n * toKana('ONAJI buttsuuji')\n * // => 'オナジ ぶっつうじ'\n * toKana('座禅‘zazen’スタイル')\n * // => '座禅「ざぜん」スタイル'\n * toKana('batsuge-mu')\n * // => 'ばつげーむ'\n * toKana('!?.:/,~-‘’“”[](){}') // Punctuation conversion\n * // => '！？。：・、〜ー「」『』［］（）｛｝'\n * toKana('we', { useObsoleteKana: true })\n * // => 'ゑ'\n * toKana('wanakana', { customKanaMapping: { na: 'に', ka: 'bana' } });\n * // => 'わにbanaに'\n */\nexport function toKana(input = '', options: Partial<Options> = {}, map?: any) {\n  let config;\n  if (!map) {\n    config = mergeWithDefaultOptions(options);\n    map = createRomajiToKanaMap(\n      config.IMEMode,\n      config.useObsoleteKana,\n      config.customKanaMapping\n    );\n  } else {\n    config = options;\n  }\n\n  // throw away the substring index information and just concatenate all the kana\n  return splitIntoConvertedKana(input, config, map)\n    .map((kanaToken) => {\n      const [start, end, kana] = kanaToken;\n      if (kana === null) {\n        // haven't converted the end of the string, since we are in IME mode\n        return input.slice(start);\n      }\n      const enforceHiragana = config.IMEMode === TO_KANA_METHODS.HIRAGANA;\n      const enforceKatakana = config.IMEMode === TO_KANA_METHODS.KATAKANA\n        || [...input.slice(start, end)].every(isCharUpperCase);\n\n      return enforceHiragana || !enforceKatakana\n        ? kana\n        : hiraganaToKatakana(kana);\n    })\n    .join('');\n}\n\n/**\n *\n * @private\n * @param {String} [input=''] input text\n * @param {DefaultOptions} [options=defaultOptions] toKana options\n * @param {Object} [map] custom mapping\n * @returns {Array[]} [[start, end, token]]\n * @example\n * splitIntoConvertedKana('buttsuuji')\n * // => [[0, 2, 'ぶ'], [2, 6, 'っつ'], [6, 7, 'う'], [7, 9, 'じ']]\n */\nexport function splitIntoConvertedKana(input = '', options: Partial<Options> = {}, map): [start: number, end: number, kana: string][] {\n  const { IMEMode, useObsoleteKana, customKanaMapping } = options;\n\n  if (!map) {\n    map = createRomajiToKanaMap(IMEMode, useObsoleteKana, customKanaMapping);\n  }\n\n  return applyMapping(input.toLowerCase(), map, !IMEMode);\n}\n\nexport default toKana;\n","import isJapanese from '../isJapanese';\nimport toKana, { createRomajiToKanaMap } from '../toKana';\nimport mergeWithDefaultOptions from './mergeWithDefaultOptions';\n\nlet LISTENERS: {id: string, inputHandler: unknown, compositionHandler: unknown}[] = [];\n/**\n * Automagically replaces input values with converted text to kana\n * @param  {defaultOptions} [options] user config overrides, default conversion is toKana()\n * @return {Function} event handler with bound options\n * @private\n */\nexport function makeOnInput(options) {\n  let prevInput;\n\n  // Enforce IMEMode if not already specified\n  const mergedConfig = Object.assign({}, mergeWithDefaultOptions(options), {\n    IMEMode: options.IMEMode || true,\n  });\n\n  const preConfiguredMap = createRomajiToKanaMap(\n    mergedConfig.IMEMode,\n    mergedConfig.useObsoleteKana,\n    mergedConfig.customKanaMapping\n  );\n\n  const triggers = [\n    ...Object.keys(preConfiguredMap),\n    ...Object.keys(preConfiguredMap).map((char) => char.toUpperCase()),\n  ];\n\n  return function onInput({ target }) {\n    if (\n      target.value !== prevInput\n      && target.dataset.ignoreComposition !== 'true'\n    ) {\n      convertInput(target, mergedConfig, preConfiguredMap, triggers, prevInput);\n    }\n  };\n}\n\nexport function convertInput(target, options, map, triggers, prevInput) {\n  const [head, textToConvert, tail] = splitInput(\n    target.value,\n    target.selectionEnd,\n    triggers\n  );\n  const convertedText = toKana(textToConvert, options, map);\n  const changed = textToConvert !== convertedText;\n\n  if (changed) {\n    const newCursor = head.length + convertedText.length;\n    const newValue = head + convertedText + tail;\n    // eslint-disable-next-line no-param-reassign\n    target.value = newValue;\n    // eslint-disable-next-line no-param-reassign\n    prevInput = newValue;\n\n    if (tail.length) {\n      // push later on event loop (otherwise mid-text insertion can be 1 char too far to the right)\n      setTimeout(() => target.setSelectionRange(newCursor, newCursor), 1);\n    } else {\n      target.setSelectionRange(newCursor, newCursor);\n    }\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    prevInput = target.value;\n  }\n}\n\nexport function onComposition({ type, target, data }) {\n  // navigator.platform is not 100% reliable for singling out all OS,\n  // but for determining desktop \"Mac OS\" it is effective enough.\n  const isMacOS = /Mac/.test(window.navigator && window.navigator.platform);\n  // We don't want to ignore on Android:\n  // https://github.com/WaniKani/WanaKana/issues/82\n  // But MacOS IME auto-closes if we don't ignore:\n  // https://github.com/WaniKani/WanaKana/issues/71\n  // Other platform Japanese IMEs pass through happily\n  if (isMacOS) {\n    if (type === 'compositionupdate' && isJapanese(data)) {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'true';\n    }\n\n    if (type === 'compositionend') {\n      // eslint-disable-next-line no-param-reassign\n      target.dataset.ignoreComposition = 'false';\n    }\n  }\n}\n\nexport function trackListeners(id, inputHandler, compositionHandler) {\n  LISTENERS = LISTENERS.concat({\n    id,\n    inputHandler,\n    compositionHandler,\n  });\n}\n\nexport function untrackListeners({ id: targetId }) {\n  LISTENERS = LISTENERS.filter(({ id }) => id !== targetId);\n}\n\nexport function findListeners(el) {\n  return (\n    el && LISTENERS.find(({ id }) => id === el.getAttribute('data-wanakana-id'))\n  );\n}\n\n// Handle non-terminal inserted input conversion:\n// | -> わ| -> わび| -> わ|び -> わs|び -> わsh|び -> わshi|び -> わし|び\n// or multiple ambiguous positioning (to select which \"s\" to work from)\n// こsこs|こsこ -> こsこso|こsこ -> こsこそ|こsこ\nexport function splitInput(text = '', cursor = 0, triggers = []) {\n  let head;\n  let toConvert;\n  let tail;\n\n  if (cursor === 0 && triggers.includes(text[0])) {\n    [head, toConvert, tail] = workFromStart(text, triggers);\n  } else if (cursor > 0) {\n    [head, toConvert, tail] = workBackwards(text, cursor);\n  } else {\n    [head, toConvert] = takeWhileAndSlice(\n      text,\n      (char) => !triggers.includes(char)\n    );\n    [toConvert, tail] = takeWhileAndSlice(\n      toConvert,\n      (char) => !isJapanese(char)\n    );\n  }\n\n  return [head, toConvert, tail];\n}\n\nfunction workFromStart(text, catalystChars) {\n  return [\n    '',\n    ...takeWhileAndSlice(\n      text,\n      (char) => catalystChars.includes(char) || !isJapanese(char, /[0-9]/)\n    ),\n  ];\n}\n\nfunction workBackwards(text = '', startIndex = 0) {\n  const [toConvert, head] = takeWhileAndSlice(\n    [...text.slice(0, startIndex)].reverse(),\n    (char) => !isJapanese(char)\n  );\n  return [\n    head.reverse().join(''),\n    toConvert\n      .split('')\n      .reverse()\n      .join(''),\n    text.slice(startIndex),\n  ];\n}\n\nfunction takeWhileAndSlice(source = {}, predicate = (x) => !!x) {\n  const result = [];\n  const { length } = source;\n  let i = 0;\n  while (i < length && predicate(source[i], i)) {\n    result.push(source[i]);\n    i += 1;\n  }\n  return [result.join(''), source.slice(i)];\n}\n","/* eslint-disable no-console */\nconst onInput = ({ target: { value, selectionStart, selectionEnd } }) => console.log('input:', { value, selectionStart, selectionEnd });\nconst onCompositionStart = () => console.log('compositionstart');\nconst onCompositionUpdate = ({\n  target: { value, selectionStart, selectionEnd },\n  data,\n}) => console.log('compositionupdate', {\n  data,\n  value,\n  selectionStart,\n  selectionEnd,\n});\nconst onCompositionEnd = () => console.log('compositionend');\n\nconst events = {\n  input: onInput,\n  compositionstart: onCompositionStart,\n  compositionupdate: onCompositionUpdate,\n  compositionend: onCompositionEnd,\n};\n\nexport const addDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.addEventListener(event, handler)\n  );\n};\n\nexport const removeDebugListeners = (input) => {\n  Object.entries(events).forEach(([event, handler]) => input.removeEventListener(event, handler)\n  );\n};\n","import { makeOnInput, onComposition, trackListeners } from './utils/dom';\nimport { addDebugListeners } from './utils/logInputEvents';\n\nconst ELEMENTS = ['TEXTAREA', 'INPUT'];\n\nlet idCounter = 0;\nconst newId = () => {\n  idCounter += 1;\n  return `${Date.now()}${idCounter}`;\n};\n\n/**\n * Binds eventListener for 'input' events to an input field to automagically replace values with kana\n * Can pass `{ IMEMode: 'toHiragana' || 'toKatakana' }` to enforce kana conversion type\n * @param  {HTMLElement} element textarea, input[type=\"text\"] etc\n * @param  {DefaultOptions} [options=defaultOptions] defaults to { IMEMode: true } using `toKana`\n * @example\n * bind(document.querySelector('#myInput'));\n */\nfunction bind(element: HTMLElement, options = {}, debug = false) {\n  if (!ELEMENTS.includes(element.nodeName)) {\n    throw new Error(\n      `Element provided to Wanakana bind() was not a valid input or textarea element.\\n Received: (${JSON.stringify(\n        element\n      )})`\n    );\n  }\n  const onInput = makeOnInput(options);\n  const id = newId();\n  element.setAttribute('data-wanakana-id', id);\n  element.setAttribute('lang', 'ja');\n  element.setAttribute('autoCapitalize', 'none');\n  element.setAttribute('autoCorrect', 'off');\n  element.setAttribute('autoComplete', 'off');\n  element.setAttribute('spellCheck', 'false');\n  element.addEventListener('input', onInput);\n  element.addEventListener('compositionupdate', onComposition);\n  element.addEventListener('compositionend', onComposition);\n  trackListeners(id, onInput, onComposition);\n  if (debug === true) {\n    addDebugListeners(element);\n  }\n}\n\nexport default bind;\n","import { findListeners, untrackListeners } from './utils/dom';\nimport { removeDebugListeners } from './utils/logInputEvents';\n\n/**\n * Unbinds eventListener from input field\n * @param  {HTMLElement} element textarea, input\n */\nexport function unbind(element: HTMLElement, debug = false) {\n  const listeners = findListeners(element);\n  if (listeners == null) {\n    throw new Error(\n      `Element provided to Wanakana unbind() had no listener registered.\\n Received: ${JSON.stringify(\n        element\n      )}`\n    );\n  }\n  const { inputHandler, compositionHandler } = listeners;\n  element.removeAttribute('data-wanakana-id');\n  element.removeAttribute('data-ignore-composition');\n  element.removeEventListener('input', inputHandler);\n  element.removeEventListener('compositionstart', compositionHandler);\n  element.removeEventListener('compositionupdate', compositionHandler);\n  element.removeEventListener('compositionend', compositionHandler);\n  untrackListeners(listeners);\n  if (debug === true) {\n    removeDebugListeners(element);\n  }\n}\n\nexport default unbind;\n","import isEmpty from './isEmpty';\nimport isCharInRange from './isCharInRange';\nimport { ROMAJI_RANGES } from '../constants';\n\n/**\n * Tests a character. Returns true if the character is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharRomaji(char = '') {\n  if (isEmpty(char)) return false;\n  return ROMAJI_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharRomaji;\n","import typeOf from './utils/typeOf';\nimport isEmpty from './utils/isEmpty';\nimport isCharRomaji from './utils/isCharRomaji';\n\n/**\n * Test if `input` is [Romaji](https://en.wikipedia.org/wiki/Romaji) (allowing [Hepburn romanisation](https://en.wikipedia.org/wiki/Hepburn_romanization))\n * @param  {String} [input=''] text\n * @param  {Regexp} [allowed] additional test allowed to pass for each char\n * @return {Boolean} true if [Romaji](https://en.wikipedia.org/wiki/Romaji)\n * @example\n * isRomaji('Tōkyō and Ōsaka')\n * // => true\n * isRomaji('12a*b&c-d')\n * // => true\n * isRomaji('あアA')\n * // => false\n * isRomaji('お願い')\n * // => false\n * isRomaji('a！b&cーd') // Zenkaku punctuation fails\n * // => false\n * isRomaji('a！b&cーd', /[！ー]/)\n * // => true\n */\nfunction isRomaji(input = '', allowed?: RegExp) {\n  const augmented = typeOf(allowed) === 'regexp';\n  return isEmpty(input)\n    ? false\n    : [...input].every((char) => {\n      const isRoma = isCharRomaji(char);\n      return !augmented ? isRoma : isRoma || allowed!.test(char);\n    });\n}\n\nexport default isRomaji;\n","import {\n  KATAKANA_START,\n  KATAKANA_END,\n} from '../constants';\n\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKatakana(char = '') {\n  return isCharInRange(char, KATAKANA_START, KATAKANA_END);\n}\n\nexport default isCharKatakana;\n","import isEmpty from './isEmpty';\nimport isCharHiragana from './isCharHiragana';\nimport isCharKatakana from './isCharKatakana';\n\n/**\n * Tests a character. Returns true if the character is [Hiragana](https://en.wikipedia.org/wiki/Hiragana) or [Katakana](https://en.wikipedia.org/wiki/Katakana).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKana(char = '') {\n  if (isEmpty(char)) return false;\n  return isCharHiragana(char) || isCharKatakana(char);\n}\n\nexport default isCharKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKana from './utils/isCharKana';\n\n/**\n * Test if `input` is [Kana](https://en.wikipedia.org/wiki/Kana) ([Katakana](https://en.wikipedia.org/wiki/Katakana) and/or [Hiragana](https://en.wikipedia.org/wiki/Hiragana))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kana](https://en.wikipedia.org/wiki/Kana)\n * @example\n * isKana('あ')\n * // => true\n * isKana('ア')\n * // => true\n * isKana('あーア')\n * // => true\n * isKana('A')\n * // => false\n * isKana('あAア')\n * // => false\n */\nfunction isKana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKana);\n}\n\nexport default isKana;\n","import isEmpty from './utils/isEmpty';\nimport isCharHiragana from './utils/isCharHiragana';\n\n/**\n * Test if `input` is [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @example\n * isHiragana('げーむ')\n * // => true\n * isHiragana('A')\n * // => false\n * isHiragana('あア')\n * // => false\n */\nfunction isHiragana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharHiragana);\n}\n\nexport default isHiragana;\n","import isEmpty from './utils/isEmpty';\nimport isCharKatakana from './utils/isCharKatakana';\n\n/**\n * Test if `input` is [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @example\n * isKatakana('ゲーム')\n * // => true\n * isKatakana('あ')\n * // => false\n * isKatakana('A')\n * // => false\n * isKatakana('あア')\n * // => false\n */\nfunction isKatakana(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKatakana);\n}\n\nexport default isKatakana;\n","import {\n  KANJI_START,\n  KANJI_END,\n} from '../constants';\n\nimport isCharInRange from './isCharInRange';\n/**\n * Tests a character. Returns true if the character is a CJK ideograph (kanji).\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharKanji(char = '') {\n  return isCharInRange(char, KANJI_START, KANJI_END);\n}\n\nexport default isCharKanji;\n","import isEmpty from './utils/isEmpty';\nimport isCharKanji from './utils/isCharKanji';\n\n/**\n * Tests if `input` is [Kanji](https://en.wikipedia.org/wiki/Kanji) ([Japanese CJK ideographs](https://en.wikipedia.org/wiki/CJK_Unified_Ideographs))\n * @param  {String} [input=''] text\n * @return {Boolean} true if all [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @example\n * isKanji('刀')\n * // => true\n * isKanji('切腹')\n * // => true\n * isKanji('勢い')\n * // => false\n * isKanji('あAア')\n * // => false\n * isKanji('🐸')\n * // => false\n */\nfunction isKanji(input = '') {\n  if (isEmpty(input)) return false;\n  return [...input].every(isCharKanji);\n}\n\nexport default isKanji;\n","import isKanji from './isKanji';\nimport isHiragana from './isHiragana';\nimport isKatakana from './isKatakana';\nimport isRomaji from './isRomaji';\n\n/**\n * Test if `input` contains a mix of [Romaji](https://en.wikipedia.org/wiki/Romaji) *and* [Kana](https://en.wikipedia.org/wiki/Kana), defaults to pass through [Kanji](https://en.wikipedia.org/wiki/Kanji)\n * @param  {String} input text\n * @param  {Object} [options={ passKanji: true }] optional config to pass through kanji\n * @return {Boolean} true if mixed\n * @example\n * isMixed('Abあア'))\n * // => true\n * isMixed('お腹A')) // ignores kanji by default\n * // => true\n * isMixed('お腹A', { passKanji: false }))\n * // => false\n * isMixed('ab'))\n * // => false\n * isMixed('あア'))\n * // => false\n */\nfunction isMixed(input = '', options = { passKanji: true }) {\n  const chars = [...input];\n  let hasKanji = false;\n  if (!options.passKanji) {\n    hasKanji = chars.some(isKanji);\n  }\n  return (chars.some(isHiragana) || chars.some(isKatakana)) && chars.some(isRomaji) && !hasKanji;\n}\n\nexport default isMixed;\n","import { KATAKANA_START, HIRAGANA_START } from '../constants';\n\nimport isCharLongDash from './isCharLongDash';\nimport isCharSlashDot from './isCharSlashDot';\nimport isCharKatakana from './isCharKatakana';\nconst isCharInitialLongDash = (char?: string, index: number) => isCharLongDash(char) && index < 1;\nconst isCharInnerLongDash = (char?: string, index: number) => isCharLongDash(char) && index > 0;\nconst isKanaAsSymbol = (char) => ['ヶ', 'ヵ'].includes(char);\nconst LONG_VOWELS = {\n  a: 'あ',\n  i: 'い',\n  u: 'う',\n  e: 'え',\n  o: 'う',\n};\n\n// inject toRomaji to avoid circular dependency between toRomaji <-> katakanaToHiragana\nfunction katakanaToHiragana(\n  input = '',\n  toRomaji,\n  { isDestinationRomaji, convertLongVowelMark } = {}\n) {\n  let previousKana = '';\n\n  return input\n    .split('')\n    .reduce((hira: string[], char: string, index) => {\n      // Short circuit to avoid incorrect codeshift for 'ー' and '・'\n      if (\n        isCharSlashDot(char)\n        || isCharInitialLongDash(char, index)\n        || isKanaAsSymbol(char)\n      ) {\n        return hira.concat(char);\n      }\n\n      // Transform long vowels: 'オー' to 'おう'\n      if (\n        convertLongVowelMark\n        && previousKana\n        && isCharInnerLongDash(char, index)\n      ) {\n        // Transform previousKana back to romaji, and slice off the vowel\n        const romaji = toRomaji(previousKana).slice(-1);\n        // However, ensure 'オー' => 'おお' => 'oo' if this is a transform on the way to romaji\n        if (\n          isCharKatakana(input[index - 1])\n          && romaji === 'o'\n          && isDestinationRomaji\n        ) {\n          return hira.concat('お');\n        }\n        return hira.concat(LONG_VOWELS[romaji]);\n        // Transform all other chars\n      }\n\n      if (!isCharLongDash(char) && isCharKatakana(char)) {\n        const code = char.charCodeAt(0) + (HIRAGANA_START - KATAKANA_START);\n        const hiraChar = String.fromCharCode(code);\n        previousKana = hiraChar;\n        return hira.concat(hiraChar);\n      }\n\n      // Pass non katakana chars through\n      previousKana = '';\n      return hira.concat(char);\n    }, [])\n    .join('');\n}\n\nexport default katakanaToHiragana;\n","import { transform, getSubTreeOf } from './kanaMapping';\nimport { ROMANIZATIONS } from '../constants';\n\nlet kanaToHepburnMap: object | null;\n\n/* eslint-disable */\n// prettier-ignore\nconst BASIC_ROMAJI = {\n  あ:'a',    い:'i',   う:'u',   え:'e',    お:'o',\n  か:'ka',   き:'ki',  く:'ku',  け:'ke',   こ:'ko',\n  さ:'sa',   し:'shi', す:'su',  せ:'se',   そ:'so',\n  た:'ta',   ち:'chi', つ:'tsu', て:'te',   と:'to',\n  な:'na',   に:'ni',  ぬ:'nu',  ね:'ne',   の:'no',\n  は:'ha',   ひ:'hi',  ふ:'fu',  へ:'he',   ほ:'ho',\n  ま:'ma',   み:'mi',  む:'mu',  め:'me',   も:'mo',\n  ら:'ra',   り:'ri',  る:'ru',  れ:'re',   ろ:'ro',\n  や:'ya',   ゆ:'yu',  よ:'yo',\n  わ:'wa',   ゐ:'wi',  ゑ:'we',  を:'wo',\n  ん: 'n',\n  が:'ga',   ぎ:'gi',  ぐ:'gu',  げ:'ge',   ご:'go',\n  ざ:'za',   じ:'ji',  ず:'zu',  ぜ:'ze',   ぞ:'zo',\n  だ:'da',   ぢ:'ji',  づ:'zu',  で:'de',   ど:'do',\n  ば:'ba',   び:'bi',  ぶ:'bu',  べ:'be',   ぼ:'bo',\n  ぱ:'pa',   ぴ:'pi',  ぷ:'pu',  ぺ:'pe',   ぽ:'po',\n  ゔぁ:'va', ゔぃ:'vi', ゔ:'vu',  ゔぇ:'ve', ゔぉ:'vo',\n};\n/* eslint-enable  */\n\nconst SPECIAL_SYMBOLS = {\n  '。': '.',\n  '、': ',',\n  '：': ':',\n  '・': '/',\n  '！': '!',\n  '？': '?',\n  '〜': '~',\n  'ー': '-',\n  '「': '‘',\n  '」': '’',\n  '『': '“',\n  '』': '”',\n  '［': '[',\n  '］': ']',\n  '（': '(',\n  '）': ')',\n  '｛': '{',\n  '｝': '}',\n  '　': ' ',\n};\n\n// んい -> n'i\nconst AMBIGUOUS_VOWELS = ['あ', 'い', 'う', 'え', 'お', 'や', 'ゆ', 'よ'];\nconst SMALL_Y = { ゃ: 'ya', ゅ: 'yu', ょ: 'yo' };\nconst SMALL_Y_EXTRA = { ぃ: 'yi', ぇ: 'ye' };\nconst SMALL_AIUEO = {\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o',\n};\nconst YOON_KANA = [\n  'き',\n  'に',\n  'ひ',\n  'み',\n  'り',\n  'ぎ',\n  'び',\n  'ぴ',\n  'ゔ',\n  'く',\n  'ふ',\n];\nconst YOON_EXCEPTIONS = {\n  し: 'sh',\n  ち: 'ch',\n  じ: 'j',\n  ぢ: 'j',\n};\nconst SMALL_KANA = {\n  っ: '',\n  ゃ: 'ya',\n  ゅ: 'yu',\n  ょ: 'yo',\n  ぁ: 'a',\n  ぃ: 'i',\n  ぅ: 'u',\n  ぇ: 'e',\n  ぉ: 'o',\n};\n\n// going with the intuitive (yet incorrect) solution where っや -> yya and っぃ -> ii\n// in other words, just assume the sokuon could have been applied to anything\nconst SOKUON_WHITELIST = {\n  b: 'b',\n  c: 't',\n  d: 'd',\n  f: 'f',\n  g: 'g',\n  h: 'h',\n  j: 'j',\n  k: 'k',\n  m: 'm',\n  p: 'p',\n  q: 'q',\n  r: 'r',\n  s: 's',\n  t: 't',\n  v: 'v',\n  w: 'w',\n  x: 'x',\n  z: 'z',\n};\n\nfunction getKanaToHepburnTree() {\n  if (kanaToHepburnMap == null) {\n    kanaToHepburnMap = createKanaToHepburnMap();\n  }\n  return kanaToHepburnMap;\n}\n\nexport function getKanaToRomajiTree(romanization) {\n  switch (romanization) {\n    case ROMANIZATIONS.HEPBURN:\n      return getKanaToHepburnTree();\n    default:\n      return {};\n  }\n}\n\nfunction createKanaToHepburnMap(): object {\n  const romajiTree = transform(BASIC_ROMAJI);\n\n  const subtreeOf = (string) => getSubTreeOf(romajiTree, string);\n  const setTrans = (string, transliteration) => {\n    subtreeOf(string)[''] = transliteration;\n  };\n\n  Object.entries(SPECIAL_SYMBOLS).forEach(([jsymbol, symbol]) => {\n    subtreeOf(jsymbol)[''] = symbol;\n  });\n\n  [...Object.entries(SMALL_Y), ...Object.entries(SMALL_AIUEO)].forEach(\n    ([roma, kana]) => {\n      setTrans(roma, kana);\n    }\n  );\n\n  // きゃ -> kya\n  YOON_KANA.forEach((kana) => {\n    const firstRomajiChar = subtreeOf(kana)[''][0];\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n    // きぃ -> kyi\n    Object.entries(SMALL_Y_EXTRA).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, firstRomajiChar + yRoma);\n    });\n  });\n\n  Object.entries(YOON_EXCEPTIONS).forEach(([kana, roma]) => {\n    // じゃ -> ja\n    Object.entries(SMALL_Y).forEach(([yKana, yRoma]) => {\n      setTrans(kana + yKana, roma + yRoma[1]);\n    });\n    // じぃ -> jyi, じぇ -> je\n    setTrans(`${kana}ぃ`, `${roma}yi`);\n    setTrans(`${kana}ぇ`, `${roma}e`);\n  });\n\n  romajiTree['っ'] = resolveTsu(romajiTree);\n\n  Object.entries(SMALL_KANA).forEach(([kana, roma]) => {\n    setTrans(kana, roma);\n  });\n\n  AMBIGUOUS_VOWELS.forEach((kana) => {\n    setTrans(`ん${kana}`, `n'${subtreeOf(kana)['']}`);\n  });\n\n  // NOTE: could be re-enabled with an option?\n  // // んば -> mbo\n  // const LABIAL = [\n  //   'ば', 'び', 'ぶ', 'べ', 'ぼ',\n  //   'ぱ', 'ぴ', 'ぷ', 'ぺ', 'ぽ',\n  //   'ま', 'み', 'む', 'め', 'も',\n  // ];\n  // LABIAL.forEach((kana) => {\n  //   setTrans(`ん${kana}`, `m${subtreeOf(kana)['']}`);\n  // });\n\n  return Object.freeze(JSON.parse(JSON.stringify(romajiTree)));\n}\n\nfunction resolveTsu(tree) {\n  return Object.entries(tree).reduce((tsuTree, [key, value]) => {\n    if (!key) {\n      // we have reached the bottom of this branch\n      const consonant = value.charAt(0);\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = Object.keys(SOKUON_WHITELIST).includes(consonant)\n        ? SOKUON_WHITELIST[consonant] + value\n        : value;\n    } else {\n      // more subtrees\n      // eslint-disable-next-line no-param-reassign\n      tsuTree[key] = resolveTsu(value);\n    }\n    return tsuTree;\n  }, {});\n}\n","import memoizeOne from 'memoize-one';\nimport { dequal } from 'dequal';\n\nimport mergeWithDefaultOptions, { type Options } from './utils/mergeWithDefaultOptions';\nimport katakanaToHiragana from './utils/katakanaToHiragana';\nimport isKatakana from './isKatakana';\nimport { getKanaToRomajiTree } from './utils/kanaToRomajiMap';\nimport { applyMapping, mergeCustomMapping } from './utils/kanaMapping';\n\n// memoize and deeply compare args so we only recreate when necessary\nexport const createKanaToRomajiMap = memoizeOne(\n  (romanization, customRomajiMapping) => {\n    let map = getKanaToRomajiTree(romanization);\n\n    if (customRomajiMapping) {\n      map = mergeCustomMapping(map, customRomajiMapping);\n    }\n\n    return map;\n  },\n  dequal\n);\n\n/**\n * Convert kana to romaji\n * @param  {String} kana text input\n * @param  {DefaultOptions} [options=defaultOptions]\n * @param  {Object} map custom mapping\n * @return {String} converted text\n * @example\n * toRomaji('ひらがな　カタカナ')\n * // => 'hiragana katakana'\n * toRomaji('げーむ　ゲーム')\n * // => 'ge-mu geemu'\n * toRomaji('ひらがな　カタカナ', { upcaseKatakana: true })\n * // => 'hiragana KATAKANA'\n * toRomaji('つじぎり', { customRomajiMapping: { じ: 'zi', つ: 'tu', り: 'li' } });\n * // => 'tuzigili'\n */\nexport function toRomaji(input = '', options: Partial<Options> = {}, map?: unknown) {\n  const config = mergeWithDefaultOptions(options);\n\n  if (!map) {\n    map = createKanaToRomajiMap(\n      config.romanization,\n      config.customRomajiMapping\n    );\n  }\n\n  // just throw away the substring index information and simply concatenate all the kana\n  return splitIntoRomaji(input, config, map)\n    .map((romajiToken) => {\n      const [start, end, romaji] = romajiToken;\n      const makeUpperCase = config.upcaseKatakana && isKatakana(input.slice(start, end));\n      return makeUpperCase ? romaji.toUpperCase() : romaji;\n    })\n    .join('');\n}\n\nfunction splitIntoRomaji(input, options, map) {\n  if (!map) {\n    map = createKanaToRomajiMap(\n      options.romanization,\n      options.customRomajiMapping\n    );\n  }\n\n  const config = Object.assign({}, { isDestinationRomaji: true }, options);\n\n  return applyMapping(\n    katakanaToHiragana(input, toRomaji, config),\n    map,\n    !options.IMEMode\n  );\n}\n\nexport default toRomaji;\n","import isEmpty from './isEmpty';\nimport { EN_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharEnglishPunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return EN_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharEnglishPunctuation;\n","import mergeWithDefaultOptions from './utils/mergeWithDefaultOptions';\nimport katakanaToHiragana from './utils/katakanaToHiragana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\nimport toKana from './toKana';\nimport toRomaji from './toRomaji';\n\n/**\n * Convert input to [Hiragana](https://en.wikipedia.org/wiki/Hiragana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toHiragana('toukyou, オオサカ')\n * // => 'とうきょう、　おおさか'\n * toHiragana('only カナ', { passRomaji: true })\n * // => 'only かな'\n * toHiragana('wi')\n * // => 'うぃ'\n * toHiragana('wi', { useObsoleteKana: true })\n * // => 'ゐ'\n */\nfunction toHiragana(input = '', options = {}) {\n  const config = mergeWithDefaultOptions(options);\n  if (config.passRomaji) {\n    return katakanaToHiragana(input, toRomaji, config);\n  }\n\n  if (isMixed(input, { passKanji: true })) {\n    const convertedKatakana = katakanaToHiragana(input, toRomaji, config);\n    return toKana(convertedKatakana.toLowerCase(), config);\n  }\n\n  if (isRomaji(input) || isCharEnglishPunctuation(input)) {\n    return toKana(input.toLowerCase(), config);\n  }\n\n  return katakanaToHiragana(input, toRomaji, config);\n}\n\nexport default toHiragana;\n","import mergeWithDefaultOptions, { type Options } from './utils/mergeWithDefaultOptions';\nimport hiraganaToKatakana from './utils/hiraganaToKatakana';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport toKana from './toKana';\nimport isRomaji from './isRomaji';\nimport isMixed from './isMixed';\n\n/**\n * Convert input to [Katakana](https://en.wikipedia.org/wiki/Katakana)\n * @param  {String} [input=''] text\n * @param  {DefaultOptions} [options=defaultOptions]\n * @return {String} converted text\n * @example\n * toKatakana('toukyou, おおさか')\n * // => 'トウキョウ、　オオサカ'\n * toKatakana('only かな', { passRomaji: true })\n * // => 'only カナ'\n * toKatakana('wi')\n * // => 'ウィ'\n * toKatakana('wi', { useObsoleteKana: true })\n * // => 'ヰ'\n */\nfunction toKatakana(input = '', options: Partial<Options> = {}) {\n  const mergedOptions = mergeWithDefaultOptions(options);\n  if (mergedOptions.passRomaji) {\n    return hiraganaToKatakana(input);\n  }\n\n  if (isMixed(input) || isRomaji(input) || isCharEnglishPunctuation(input)) {\n    const hiragana = toKana(input.toLowerCase(), mergedOptions);\n    return hiraganaToKatakana(hiragana);\n  }\n\n  return hiraganaToKatakana(input);\n}\n\nexport default toKatakana;\n","import isEmpty from './isEmpty';\nimport { JA_PUNCTUATION_RANGES } from '../constants';\nimport isCharInRange from './isCharInRange';\n\n/**\n * Tests a character. Returns true if the character is considered English punctuation.\n * @param  {String} char character string to test\n * @return {Boolean}\n */\nfunction isCharJapanesePunctuation(char = '') {\n  if (isEmpty(char)) return false;\n  return JA_PUNCTUATION_RANGES.some(([start, end]) => isCharInRange(char, start, end));\n}\n\nexport default isCharJapanesePunctuation;\n","import isEmpty from './utils/isEmpty';\nimport isCharEnglishPunctuation from './utils/isCharEnglishPunctuation';\nimport isCharJapanesePunctuation from './utils/isCharJapanesePunctuation';\nimport isCharRomaji from './utils/isCharRomaji';\nimport isCharKanji from './utils/isCharKanji';\nimport isCharHiragana from './utils/isCharHiragana';\nimport isCharKatakana from './utils/isCharKatakana';\nimport isCharJapanese from './utils/isCharJapanese';\n\nconst isCharEnSpace = (x: unknown) => x === ' ';\nconst isCharJaSpace = (x): unknown => x === '　';\nconst isCharJaNum = (x: unknown) => typeof x === 'string' && /[０-９]/.test(x);\nconst isCharEnNum = (x: unknown) => typeof x === 'string' && /[0-9]/.test(x);\n\nexport const TOKEN_TYPES = {\n  EN: 'en' as const,\n  JA: 'ja',\n  EN_NUM: 'englishNumeral',\n  JA_NUM: 'japaneseNumeral',\n  EN_PUNC: 'englishPunctuation',\n  JA_PUNC: 'japanesePunctuation',\n  KANJI: 'kanji',\n  HIRAGANA: 'hiragana',\n  KATAKANA: 'katakana',\n  SPACE: 'space',\n  OTHER: 'other' as const,\n} as const;\n\ntype TokenType = typeof TOKEN_TYPES;\n\n// prettier-ignore\nexport function getType(input, compact = false): TokenType {\n  const {\n    EN, JA, EN_NUM, JA_NUM, EN_PUNC, JA_PUNC, KANJI, HIRAGANA, KATAKANA, SPACE, OTHER,\n  } = TOKEN_TYPES;\n\n  if (compact) {\n    switch (true) {\n      case isCharJaNum(input): return TOKEN_TYPES.OTHER;\n      case isCharEnNum(input): return OTHER;\n      case isCharEnSpace(input): return TOKEN_TYPES.EN;\n      case isCharEnglishPunctuation(input): return OTHER;\n      case isCharJaSpace(input): return JA;\n      case isCharJapanesePunctuation(input): return OTHER;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  } else {\n    switch (true) {\n      case isCharJaSpace(input): return SPACE;\n      case isCharEnSpace(input): return SPACE;\n      case isCharJaNum(input): return JA_NUM;\n      case isCharEnNum(input): return EN_NUM;\n      case isCharEnglishPunctuation(input): return EN_PUNC;\n      case isCharJapanesePunctuation(input): return JA_PUNC;\n      case isCharKanji(input): return KANJI;\n      case isCharHiragana(input): return HIRAGANA;\n      case isCharKatakana(input): return KATAKANA;\n      case isCharJapanese(input): return JA;\n      case isCharRomaji(input): return EN;\n      default: return OTHER;\n    }\n  }\n}\n\n/**\n * Splits input into array of strings separated by opinionated token types\n * `'en', 'ja', 'englishNumeral', 'japaneseNumeral','englishPunctuation', 'japanesePunctuation','kanji', 'hiragana', 'katakana', 'space', 'other'`.\n * If `{ compact: true }` then many same-language tokens are combined (spaces + text, kanji + kana, numeral + punctuation).\n * If `{ detailed: true }` then return array will contain `{ type, value }` instead of `'value'`\n * @param  {String} input text\n * @param  {Object} [options={ compact: false, detailed: false}] options to modify output style\n * @return {String|Object[]} text split into tokens containing values, or detailed object\n * @example\n * tokenize('ふふフフ')\n * // ['ふふ', 'フフ']\n *\n * tokenize('感じ')\n * // ['感', 'じ']\n *\n * tokenize('truly 私は悲しい')\n * // ['truly', ' ', '私', 'は', '悲', 'しい']\n *\n * tokenize('truly 私は悲しい', { compact: true })\n * // ['truly ', '私は悲しい']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！')\n * // [ '5', 'romaji', ' ', 'here', '...!?', '漢字', 'ひらがな', 'カタ', '　', 'カナ', '４', '「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがな４カタ　カナ「ＳＨＩＯ」。！', { compact: true })\n * // [ '5', 'romaji here', '...!?', '漢字ひらがなカタ　カナ', '４「', 'ＳＨＩＯ', '」。！']\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { detailed: true })\n * // [\n *  { type: 'englishNumeral', value: '5' },\n *  { type: 'en', value: 'romaji' },\n *  { type: 'space', value: ' ' },\n *  { type: 'en', value: 'here' },\n *  { type: 'englishPunctuation', value: '...!?' },\n *  { type: 'kanji', value: '漢字' },\n *  { type: 'hiragana', value: 'ひらがな' },\n *  { type: 'katakana', value: 'カタ' },\n *  { type: 'space', value: '　' },\n *  { type: 'katakana', value: 'カナ' },\n *  { type: 'japaneseNumeral', value: '４' },\n *  { type: 'japanesePunctuation', value: '「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'japanesePunctuation', value: '」。！' },\n *  { type: 'space', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n * ]\n *\n * tokenize('5romaji here...!?漢字ひらがなカタ　カナ４「ＳＨＩＯ」。！ لنذهب', { compact: true, detailed: true})\n * // [\n *  { type: 'other', value: '5' },\n *  { type: 'en', value: 'romaji here' },\n *  { type: 'other', value: '...!?' },\n *  { type: 'ja', value: '漢字ひらがなカタ　カナ' },\n *  { type: 'other', value: '４「' },\n *  { type: 'ja', value: 'ＳＨＩＯ' },\n *  { type: 'other', value: '」。！' },\n *  { type: 'en', value: ' ' },\n *  { type: 'other', value: 'لنذهب' },\n *]\n */\nfunction tokenize(input?: string, { compact = false, detailed = false } = {}) {\n  if (input == null || isEmpty(input)) {\n    return [];\n  }\n  const chars = [...input];\n  let initial = chars.shift();\n  let prevType = getType(initial, compact);\n  initial = detailed ? { type: prevType, value: initial } : initial;\n\n  const result = chars.reduce(\n    (tokens, char) => {\n      const currType = getType(char, compact);\n      const sameType = currType === prevType;\n      prevType = currType;\n      let newValue = char;\n\n      if (sameType) {\n        newValue = (detailed ? tokens.pop().value : tokens.pop()) + newValue;\n      }\n\n      return detailed\n        ? tokens.concat({ type: currType, value: newValue })\n        : tokens.concat(newValue);\n    },\n    [initial]\n  );\n  return result;\n}\n\nexport default tokenize;\n","import isJapanese from './isJapanese';\nimport isKana from './isKana';\nimport isKanji from './isKanji';\nimport tokenize from './tokenize';\n\nconst isLeadingWithoutInitialKana = (input, leading) => leading && !isKana(input[0]);\nconst isTrailingWithoutFinalKana = (input, leading) => !leading && !isKana(input[input.length - 1]);\nconst isInvalidMatcher = (input, matchKanji) =>\n  (matchKanji && ![...matchKanji].some(isKanji)) || (!matchKanji && isKana(input));\n\n/**\n * Strips [Okurigana](https://en.wikipedia.org/wiki/Okurigana)\n * @param  {String} input text\n * @param  {Object} [options={ leading: false, matchKanji: '' }] optional config\n * @return {String} text with okurigana removed\n * @example\n * stripOkurigana('踏み込む')\n * // => '踏み込'\n * stripOkurigana('お祝い')\n * // => 'お祝'\n * stripOkurigana('お腹', { leading: true });\n * // => '腹'\n * stripOkurigana('ふみこむ', { matchKanji: '踏み込む' });\n * // => 'ふみこ'\n * stripOkurigana('おみまい', { matchKanji: 'お祝い', leading: true });\n * // => 'みまい'\n */\nfunction stripOkurigana(input = '', { leading = false, matchKanji = '' } = {}) {\n  if (\n    !isJapanese(input) ||\n    isLeadingWithoutInitialKana(input, leading) ||\n    isTrailingWithoutFinalKana(input, leading) ||\n    isInvalidMatcher(input, matchKanji)\n  ) {\n    return input;\n  }\n\n  const chars = matchKanji || input;\n  const okuriganaRegex = new RegExp(\n    leading ? `^${tokenize(chars).shift()}` : `${tokenize(chars).pop()}$`\n  );\n  return input.replace(okuriganaRegex, '');\n}\n\nexport default stripOkurigana;\n"],"names":["typeOf","value","isEmpty","input","isCharInRange","char","start","end","code","VERSION","TO_KANA_METHODS","ROMANIZATIONS","DEFAULT_OPTIONS","LATIN_UPPERCASE_START","LATIN_UPPERCASE_END","LOWERCASE_ZENKAKU_START","LOWERCASE_ZENKAKU_END","UPPERCASE_ZENKAKU_START","UPPERCASE_ZENKAKU_END","HIRAGANA_START","HIRAGANA_END","KATAKANA_START","KATAKANA_END","KANJI_START","KANJI_END","PROLONGED_SOUND_MARK","KANA_SLASH_DOT","ZENKAKU_NUMBERS","ZENKAKU_UPPERCASE","ZENKAKU_LOWERCASE","ZENKAKU_PUNCTUATION_1","ZENKAKU_PUNCTUATION_2","ZENKAKU_PUNCTUATION_3","ZENKAKU_PUNCTUATION_4","ZENKAKU_SYMBOLS_CURRENCY","HIRAGANA_CHARS","KATAKANA_CHARS","HANKAKU_KATAKANA","KATAKANA_PUNCTUATION","KANA_PUNCTUATION","CJK_SYMBOLS_PUNCTUATION","COMMON_CJK","RARE_CJK","KANA_RANGES","JA_PUNCTUATION_RANGES","JAPANESE_RANGES","MODERN_ENGLISH","HEPBURN_MACRON_RANGES","SMART_QUOTE_RANGES","ROMAJI_RANGES","EN_PUNCTUATION_RANGES","isCharJapanese","isJapanese","allowed","augmented","isJa","safeIsNaN","isEqual","first","second","areInputsEqual","newInputs","lastInputs","i","memoizeOne","resultFn","cache","memoized","newArgs","_i","lastResult","has","find","iter","tar","key","dequal","foo","bar","ctor","len","tmp","mergeWithDefaultOptions","opts","applyMapping","str","mapping","convertEnding","root","nextSubtree","tree","nextChar","newChunk","remaining","currentCursor","firstChar","parse","lastCursor","subtree","transform","map","endOfBranch","getSubTreeOf","string","correctSubTree","createCustomMapping","customMap","customTree","roma","kana","subTree","mapCopy","transformMap","mapSubtree","customSubtree","newSubtree","mergeCustomMapping","customMapping","BASIC_KUNREI","SPECIAL_SYMBOLS","CONSONANTS","SMALL_Y","SMALL_VOWELS","ALIASES","SMALL_LETTERS","SPECIAL_CASES","AIUEO_CONSTRUCTIONS","createRomajiToKanaMap","kanaTree","subtreeOf","consonant","yKana","symbol","jsymbol","aiueoKana","vowel","nChar","alternative","allExceptLast","last","parentTree","getAlternatives","list","alt","kunreiRoma","chars","xRoma","xSubtree","altRoma","prefix","altParentTree","addTsu","tsuTree","romajiToKanaMap","getRomajiToKanaTree","USE_OBSOLETE_KANA_MAP","IME_MODE_MAP","isCharUpperCase","isCharLongDash","isCharSlashDot","isCharHiragana","hiraganaToKatakana","kata","kataChar","IMEMode","useObsoleteKana","customKanaMapping","toKana","options","config","splitIntoConvertedKana","kanaToken","enforceHiragana","enforceKatakana","LISTENERS","makeOnInput","prevInput","mergedConfig","preConfiguredMap","triggers","target","convertInput","head","textToConvert","tail","splitInput","convertedText","newCursor","newValue","onComposition","type","data","trackListeners","id","inputHandler","compositionHandler","untrackListeners","targetId","findListeners","el","text","cursor","toConvert","workFromStart","workBackwards","takeWhileAndSlice","catalystChars","startIndex","source","predicate","x","result","length","onInput","selectionStart","selectionEnd","onCompositionStart","onCompositionUpdate","onCompositionEnd","events","addDebugListeners","event","handler","removeDebugListeners","ELEMENTS","idCounter","newId","bind","element","debug","unbind","listeners","isCharRomaji","isRomaji","isRoma","isCharKatakana","isCharKana","isKana","isHiragana","isKatakana","isCharKanji","isKanji","isMixed","hasKanji","isCharInitialLongDash","index","isCharInnerLongDash","isKanaAsSymbol","LONG_VOWELS","katakanaToHiragana","toRomaji","isDestinationRomaji","convertLongVowelMark","previousKana","hira","romaji","hiraChar","kanaToHepburnMap","BASIC_ROMAJI","AMBIGUOUS_VOWELS","SMALL_Y_EXTRA","SMALL_AIUEO","YOON_KANA","YOON_EXCEPTIONS","SMALL_KANA","SOKUON_WHITELIST","getKanaToHepburnTree","createKanaToHepburnMap","getKanaToRomajiTree","romanization","romajiTree","setTrans","transliteration","firstRomajiChar","yRoma","resolveTsu","createKanaToRomajiMap","customRomajiMapping","splitIntoRomaji","romajiToken","isCharEnglishPunctuation","toHiragana","convertedKatakana","toKatakana","mergedOptions","hiragana","isCharJapanesePunctuation","isCharEnSpace","isCharJaSpace","isCharJaNum","isCharEnNum","TOKEN_TYPES","getType","compact","EN","JA","EN_NUM","JA_NUM","EN_PUNC","JA_PUNC","KANJI","HIRAGANA","KATAKANA","SPACE","OTHER","tokenize","detailed","initial","prevType","tokens","currType","sameType","isLeadingWithoutInitialKana","leading","isTrailingWithoutFinalKana","isInvalidMatcher","matchKanji","stripOkurigana","okuriganaRegex"],"mappings":"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"}